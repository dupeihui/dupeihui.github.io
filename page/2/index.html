<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 5.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"example.com","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}}};
  </script>

  <meta name="description" content="Cream rises to the top.">
<meta property="og:type" content="website">
<meta property="og:title" content="Hexo">
<meta property="og:url" content="http://example.com/page/2/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="Cream rises to the top.">
<meta property="og:locale" content="zh_CN">
<meta property="article:author" content="PD">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="http://example.com/page/2/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : true,
    isPost : false,
    lang   : 'zh-CN'
  };
</script>

  <title>Hexo</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Hexo</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
        <li class="menu-item menu-item-about">

    <a href="/about/" rel="section"><i class="fa fa-user fa-fw"></i>关于</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content index posts-expand">
            
      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/29/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/29/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/" class="post-title-link" itemprop="url">redis主从架构模式</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-29 23:36:34" itemprop="dateCreated datePublished" datetime="2020-12-29T23:36:34+08:00">2020-12-29</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:22:54" itemprop="dateModified" datetime="2021-02-23T21:22:54+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="简单介绍"><a href="#简单介绍" class="headerlink" title="简单介绍"></a>简单介绍</h2><p>单机的redis，能够承载的QPS大概在上万到几万不等。对于缓存来说，一般都是用来支撑读高并发。因此架构做成主从（master-slave）架构，一主多从，主负责写，并且将数据复制到其他的slave节点，从节点负责读。所有的读请求全部走从节点。这样也可以很轻松实现水平扩容，支撑读高并发。</p>
<h2 id="redis主从复制的核心原理"><a href="#redis主从复制的核心原理" class="headerlink" title="redis主从复制的核心原理"></a>redis主从复制的核心原理</h2><p>当启动一个slave node的时候，它会发送一个PSYNC命令给master node。<br>如果这是 slave node 初次连接到 master node，那么会触发一次 full resynchronization 全量复制。此时 master 会启动一个后台线程，开始生成一份 RDB 快照文件，同时还会将从客户端 client 新收到的所有写命令缓存在内存中。RDB 文件生成完毕后， master 会将这个 RDB 发送给 slave，slave 会先写入本地磁盘，然后再从本地磁盘加载到内存中，接着 master 会将内存中缓存的写命令发送到 slave，slave 也会同步这些数据。slave node 如果跟 master node 有网络故障，断开了连接，会自动重连，连接之后 master node 仅会复制给 slave 部分缺少的数据。  </p>
<img src="/2020/12/29/redis%E4%B8%BB%E4%BB%8E%E6%9E%B6%E6%9E%84%E6%A8%A1%E5%BC%8F/redis-master-slave.png" class="">

<h2 id="redis配置主从架构"><a href="#redis配置主从架构" class="headerlink" title="redis配置主从架构"></a>redis配置主从架构</h2><p>进入从节点，打开redis配置文件，进行如下配置：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># 配置所属主服务器ip和端口</span><br><span class="line"># replicaof &lt;masterip&gt; &lt;masterport&gt;</span><br><span class="line">replicaof 192.168.1.1 6379</span><br><span class="line"></span><br><span class="line"># 配置所属主服务器的密码</span><br><span class="line"># masterauth &lt;master-passord&gt;</span><br><span class="line">masterauth 123456</span><br><span class="line"></span><br><span class="line"># 从服务器通常是只读，配置只读</span><br><span class="line">replica-read-only yes</span><br><span class="line"></span><br><span class="line"># 主从复制同步策略：disk or socket，无磁盘化复制</span><br><span class="line">repl-diskless-sync no</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/13/redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/redis%E7%BC%93%E5%AD%98%E8%BF%87%E6%9C%9F%E5%A4%84%E7%90%86%E4%B8%8E%E5%86%85%E5%AD%98%E6%B7%98%E6%B1%B0%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">redis缓存过期处理与内存淘汰机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 17:17:47" itemprop="dateCreated datePublished" datetime="2020-12-13T17:17:47+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:22:44" itemprop="dateModified" datetime="2021-02-23T21:22:44+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="已过期的key如何处理"><a href="#已过期的key如何处理" class="headerlink" title="已过期的key如何处理"></a>已过期的key如何处理</h2><p>设置了expire的key缓存过期了，但是服务器的内存还是会被占用，这是因为redis所基于的两种删除策略，redis有两种策略：<br>1.（主动）定时删除  </p>
<ul>
<li>定时随机的检查过期的key，如果过期则清理删除。</li>
</ul>
<p>2.（被动）惰性删除</p>
<ul>
<li>当客户端请求一个已经过期的key的时候，那么redis会检查这个key是否过期了，如果过期了，则删除。这种策略对CPU比较友好，不会有太多的损耗，但是内存占用会比较高。</li>
</ul>
<p>所以，虽然key过期了，但是只要没有被redis清理，那么内存还是会被占用着。</p>
<h2 id="内存淘汰机制"><a href="#内存淘汰机制" class="headerlink" title="内存淘汰机制"></a>内存淘汰机制</h2><p>内存占满了，可以使用磁盘来保存，但是没有意义，因为磁盘没有内存快，会影响redis性能。所以，当内存占用满了以后，redis提供了一套缓存淘汰机制：MEMORY MANAGEMENT</p>
<ul>
<li><p>maxmemory &lt;bytes&gt;<br>  最大可使用内存，超过则开始清理缓存</p>
</li>
<li><p>maxmemory-policy noeviction<br>  volatile-lru  #在那些设置了expire过期时间的key中，使用近似的LRU（Least Recently Used）算法清除key<br>  allkeys-lru  #在所有的key中使用近似的LRU（Least Recently Used）算法清除key<br>  volatile-lfu  #在那些设置了expire过期时间的key中，使用近似的LFU（Least Frequently Used）算法清除key<br>  allkeys-lfu  #在所有的key中使用近似的LFU（Least Frequently Used）算法清除key<br>  volatile-random  #在那些设置了expire过期时间的key中，随机清除key<br>  allkeys-random  #在所有的key中随机清除key<br>  volatile-ttl  #在那些设置了expire过期时间的key中，删除即将过期的<br>  noeviction  #缓存中的key永不删除，返回错误</p>
</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/13/Redis%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/13/Redis%E7%9A%84%E4%B8%A4%E7%A7%8D%E6%8C%81%E4%B9%85%E5%8C%96%E6%9C%BA%E5%88%B6/" class="post-title-link" itemprop="url">Redis的两种持久化机制</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-13 13:44:13" itemprop="dateCreated datePublished" datetime="2020-12-13T13:44:13+08:00">2020-12-13</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:22:19" itemprop="dateModified" datetime="2021-02-23T21:22:19+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>RDB : Redis DataBase</strong><br><strong>AOF : Append Only File</strong></p>
<h2 id="RDB"><a href="#RDB" class="headerlink" title="RDB"></a>RDB</h2><h3 id="什么是RDB"><a href="#什么是RDB" class="headerlink" title="什么是RDB"></a>什么是RDB</h3><p>RDB：每隔一段时间，把内存中的数据写入磁盘的临时文件，作为快照，恢复的时候把快照文件读进内存。如果宕机重启，那么内存里的数据肯定会没有的，再次重启redis后，则会恢复。</p>
<h3 id="备份与恢复"><a href="#备份与恢复" class="headerlink" title="备份与恢复"></a>备份与恢复</h3><p>内存备份–&gt;磁盘临时文件<br>临时文件–&gt;恢复到内存</p>
<h3 id="RDB优劣势"><a href="#RDB优劣势" class="headerlink" title="RDB优劣势"></a>RDB优劣势</h3><ul>
<li><p>优势<br>  1.每个一段时间备份，全量备份<br>  2.灾备简单，可以远程传输<br>  3.子进程备份的时候，主进程不会有任何io操作（不会有写入修改或删除），保证备份数据的完整性<br>  4.相对AOF来说，当有更大文件的时候可以快速重启恢复</p>
</li>
<li><p>劣势<br>  1.发生故障时，有可能会丢失最后一次的备份数据<br>  2.子进程所占用的内存比会和父进程一模一样，如会造成CPU负担<br>  3.由于定时全量备份是重量级操作，所以对于实时备份，就无法处理了</p>
</li>
</ul>
<h3 id="RDB的配置"><a href="#RDB的配置" class="headerlink" title="RDB的配置"></a>RDB的配置</h3><ul>
<li><p>rdb文件保存位置，可以在redis.conf自定义：<br>  /user/local/redis/working/dump.rdb</p>
</li>
<li><p>默认保存机制：  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># save &lt;seconds&gt; &lt;changes&gt;</span><br><span class="line"># In the example below the behaviour will be to save:</span><br><span class="line"># after 900 sec (15 min) if at least 1 key changed</span><br><span class="line"># after 300 sec (5 min) if at least 10 keys changed</span><br><span class="line"># after 60 sec if at least 10000 keys changed   </span><br><span class="line">save 900 1</span><br><span class="line">save 300 10</span><br><span class="line">save 60 10000</span><br></pre></td></tr></table></figure></li>
<li><p>stop-writes-on-bgsave-error<br>  yes : 如果save过程出错，则停止写操作<br>  no : 可能造成数据不一致</p>
</li>
<li><p>rdbcompression<br>  yes : 开启rdb压缩模式<br>  no : 关闭，会节约cpu损耗，但是文件会大</p>
</li>
<li><p>rdbchecksum<br>  yes : 使用CRC64算法校验对rdb进行数据校验，有10%的性能损耗<br>  no : 不校验</p>
</li>
</ul>
<p><strong>总结</strong><br>RDB适合大量数据的恢复，但是数据的完整性和一致性可能会不足</p>
<h2 id="AOF"><a href="#AOF" class="headerlink" title="AOF"></a>AOF</h2><h3 id="什么是AOF"><a href="#什么是AOF" class="headerlink" title="什么是AOF"></a>什么是AOF</h3><p>AOF：以日志的形式来记录用户请求的写操作。读操作不会记录，因为写操作才会存储。文件以追加的形式而不是修改方式。redis的AOF恢复其实就是把追加的文件从开始到结尾读取执行写操作。</p>
<h3 id="AOF的优劣势"><a href="#AOF的优劣势" class="headerlink" title="AOF的优劣势"></a>AOF的优劣势</h3><ul>
<li><p>优势<br>  1.AOF更加耐用，可以以秒级别为单位备份，如果发生问题，也只会丢失最后一秒的数据，大大增加了可靠性和数据完整性。所以AOF可以每秒备份一次，使用fsync操作。<br>  2.以log日志形式追加，如果磁盘满了，会执行redis-check-aof工具。<br>  3.当数据太大的时候，redis可以在后台自动重写aof。当redis继续把日志追加到老的文件中去时，重写也是非常非常安全的，不会影响客户端的读写操作。<br>  4.AOF日志包含所有写操作，会更加便于redis的解析恢复。</p>
</li>
<li><p>劣势<br>  1.相同的数据，同一份数据，AOF比RDB大<br>  2.针对不同的同步机制，AOF会比RDB慢，因为AOF每秒都会备份写操作，这样相对于RDB来说同步略慢。每秒备份fsync没毛病，但是如果客户端的每次写入就做一次备份fsync的话，那么redis的性能就会下降。<br>  3.AOF发生过罕见的bug，就是数据恢复的时候数据不完整，这样显得AOF会比较脆弱，容易出现bug，因为AOF没有RDB那么简单，但是为了防止bug的产生，AOF就不会根据旧的指令去重构，而是根据当时缓存中存在的数据指令去做重构，这样就更加健壮和可靠了。</p>
</li>
</ul>
<h3 id="AOF的配置"><a href="#AOF的配置" class="headerlink" title="AOF的配置"></a>AOF的配置</h3><ul>
<li><p>appendonly no<br>  AOF默认关闭，yes可以开启</p>
</li>
<li><p>appendfilename “appendonly.aof”<br>  AOF文件名</p>
</li>
<li><p>appendfsync everysec<br>  no : 不同步<br>  everysec : 每秒备份，推荐使用<br>  always : 每次操作都会备份，安全并且数据完整，但是性能差</p>
</li>
<li><p>no-appendfsync-on-rewrite no<br>  重写的时候是否要同步，no可以保证数据安全</p>
</li>
<li><p>auto-aof-rewrite-percentage 100</p>
</li>
<li><p>auto-aof-rewrite-min-size 64mb<br>  重写机制：避免文件越来越大，自动优化压缩指令，会fork一个新的进程去完成重写动作，新进程里的内存数据会被重写，此时旧的aof文件不会被读取使用，类似rdb<br>  当前AOF文件的大小是上次AOF文件大小的100%，并且文件体积达到64m，满足两者则触发重写</p>
</li>
</ul>
<p><strong>到底采用RDB还是AOF呢？</strong><br>1.如果你能接受一段时间的缓存丢失，那么可以使用RDB<br>2.如果你对实时性的数据比较关心，那么就使用AOF<br>3.使用RDB和AOF结合一起做持久化，RDB做冷备，可以在不同时期对不同版本做恢复，AOF做热备，保证数据仅仅有1秒的损失。当AOF破损不可用时，那么再用RDB恢复，这样就做到两者的相互结合，也就是说redis恢复会先加载AOF，如果AOF有问题会再加载RDB，这样就达到冷热备份的目的了。</p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/06/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/06/Nginx%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">Nginx解决跨域问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-06 22:40:45" itemprop="dateCreated datePublished" datetime="2020-12-06T22:40:45+08:00">2020-12-06</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:34" itemprop="dateModified" datetime="2021-02-23T21:21:34+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前后端在联调的时候经常会出现跨域问题，这是因为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a>：</p>
<p><strong>什么是跨域？</strong></p>
<blockquote>
<p>浏览器从一个域名的网页去请求另一个域名的资源时，协议、主机、端口任一不同，都是跨域。</p>
</blockquote>
<p>下表给出了与URL<code>http://store.company.com/dir/page.html</code>的源进行比对的示例：</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">结果</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://store.company.com/dir2/other.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com/dir/inner/another.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>https://store.company.com/secure.html</code></td>
<td align="left">失败</td>
<td align="left">协议不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com:81/dir/etc.html</code></td>
<td align="left">失败</td>
<td align="left">端口不同（<code>http://</code>默认端口是80）</td>
</tr>
<tr>
<td align="left"><code>http://news.company.com/dir/other.html</code></td>
<td align="left">失败</td>
<td align="left">主机不同</td>
</tr>
</tbody></table>
<p>这里我通过nginx部署前端代码，前端代码存放在linux机目录/home/foodie-shop：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       8080;</span><br><span class="line">        server_name  192.168.2.247;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   &#x2F;home&#x2F;foodie-shop;</span><br><span class="line">            index  index.html;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>后端代码通过tomcat部署，再通过nginx反向代理：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#配置上游服务器</span><br><span class="line">upstream tomcats &#123;</span><br><span class="line">        server 192.168.2.247:8088;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen  88;</span><br><span class="line">        server_name     192.168.2.247;</span><br><span class="line"></span><br><span class="line">        location ~ &#123;</span><br><span class="line">                proxy_pass      http:&#x2F;&#x2F;tomcats;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>后端接口服务通过nginx配置解决跨域问题</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#配置上游服务器</span><br><span class="line">upstream tomcats &#123;</span><br><span class="line">        server 192.168.2.247:8088;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">        listen  88;</span><br><span class="line">        server_name     192.168.2.247;</span><br><span class="line"></span><br><span class="line">        #允许跨域请求的域,*代表所有</span><br><span class="line">        #add_header &#39;Access-Control-Allow-Origin&#39; *;</span><br><span class="line">        #允许带上cookie请求</span><br><span class="line">        add_header &#39;Access-Control-Allow-Credential&#39; &#39;true&#39;;</span><br><span class="line">        #允许请求的方法，比如GET&#x2F;POST&#x2F;PUT&#x2F;DELETE</span><br><span class="line">        add_header &#39;Access-Control-Allow-Methods&#39; *;</span><br><span class="line">        #允许请求的header</span><br><span class="line">        add_header &#39;Access-Control_Allow-Headers&#39; *;</span><br><span class="line"></span><br><span class="line">        location ~ &#123;</span><br><span class="line">                proxy_pass      http:&#x2F;&#x2F;tomcats;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/05/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/05/nginx%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E7%AE%97%E6%B3%95/" class="post-title-link" itemprop="url">nginx负载均衡算法</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-05 21:38:14" itemprop="dateCreated datePublished" datetime="2020-12-05T21:38:14+08:00">2020-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:26" itemprop="dateModified" datetime="2021-02-23T21:21:26+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>1、round-robin（默认）</strong><br>轮训方式，依次将请求分配到各个后台服务器，默认的负载均衡方式。适用于后台机器性能一致的情况。挂掉的服务自动从服务列表剔出。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.2.191:8080;</span><br><span class="line">    server 192.168.2.230:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2、weight</strong><br>根据权重分发请求到不同机器，weight的值越大，服务器分配的请求越多，主要用于后端每台服务器性能不均衡的情况。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server 192.168.2.191:8080 weigth&#x3D;1;</span><br><span class="line">    server 192.168.2.230:8080 weight&#x3D;2;</span><br><span class="line">    server 192.168.2.237:8080 weight&#x3D;3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3、ip_hash</strong><br>每个请求按访问IP的哈希结果分配，使来自同一个IP的访客固定访问一台后端服务器，并且可以有效解决动态网页存在的session共享问题。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    ip_hash;</span><br><span class="line">    server 192.168.2.191:8080;</span><br><span class="line">    server 192.168.2.230:8080;</span><br><span class="line">    server 192.168.2.237:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4、url_hash</strong><br>按访问的URL的哈希结果来分配请求，使每个URL定向到一台后端服务器，可以进一步提高后端缓存服务器的效率。Nginx本身不支持url_hash，如果需要这种调度算法，则必须安装Nginx的hash软件包。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $request_uri;</span><br><span class="line">    hash_method crc32;</span><br><span class="line">    server 192.168.2.191:8080;</span><br><span class="line">    server 192.168.2.230:8080;</span><br><span class="line">    server 192.168.2.237:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>5、least_conn</strong><br>将请求分配给连接数最少的服务器，同时考虑服务器的权重，如果有多个这样的服务器，则依次适用加权轮训负载平衡方法进行尝试。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    least_conn;</span><br><span class="line">    server 192.168.2.191:8080 weigth&#x3D;1;</span><br><span class="line">    server 192.168.2.230:8080 weigth&#x3D;2;</span><br><span class="line">    server 192.168.2.237:8080 weigth&#x3D;3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>6、fair</strong><br>比weight、ip_hash更智能的负载均衡算法，fair算法可以根据页面大小和加载时间长短智能地进行负载均衡，也就是根据后端服务器的响应时间来分配请求，响应时间短的优先分配。Nginx本身不支持fair，如果需要这种调度算法，则必须安装upsteram_fair模块。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    fair;</span><br><span class="line">    server 192.168.2.191:8080;</span><br><span class="line">    server 192.168.2.230:8080;</span><br><span class="line">    server 192.168.2.237:8080;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/12/05/nginx%E6%A8%A1%E5%9D%97%EF%BC%9Angx-stream-upstream-module/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/12/05/nginx%E6%A8%A1%E5%9D%97%EF%BC%9Angx-stream-upstream-module/" class="post-title-link" itemprop="url">nginx模块：ngx_stream_upstream_module</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-12-05 17:34:28" itemprop="dateCreated datePublished" datetime="2020-12-05T17:34:28+08:00">2020-12-05</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:40" itemprop="dateModified" datetime="2021-02-23T21:21:40+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p><strong>官方介绍</strong>：<br>The <code>ngx_stream_upstream_module</code> module (1.9.0) is used to define groups of servers that can be referenced by the proxy_pass directive.  </p>
<p><strong>Example Configuration</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    hash $remote_addr consistent;</span><br><span class="line"></span><br><span class="line">    server backend1.example.com:12345  weight&#x3D;5;</span><br><span class="line">    server backend2.example.com:12345;</span><br><span class="line">    server unix:&#x2F;tmp&#x2F;backend3;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:12345   backup;</span><br><span class="line">    server backup2.example.com:12345   backup;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">server &#123;</span><br><span class="line">    listen 12346;</span><br><span class="line">    proxy_pass backend;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>Directives</strong></p>
<blockquote>
<p>Syntax:    upstream name { … }<br>Default:    —<br>Context:    stream</p>
</blockquote>
<p>Defines a group of servers. Servers can listen on different ports. In addition, servers listening on TCP and UNIX-domain sockets can be mixed.<br>Example:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">upstream backend &#123;</span><br><span class="line">    server backend1.example.com:12345 weight&#x3D;5;</span><br><span class="line">    server 127.0.0.1:12345            max_fails&#x3D;3 fail_timeout&#x3D;30s;</span><br><span class="line">    server unix:&#x2F;tmp&#x2F;backend2;</span><br><span class="line">    server backend3.example.com:12345 resolve;</span><br><span class="line"></span><br><span class="line">    server backup1.example.com:12345  backup;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>By default, connections are distributed between the servers using a weighted round-robin balancing method. In the above example, each 7 connections will be distributed as follows: 5 connections go to <code>backend1.example.com:12345</code> and one connection to each of the second and third servers. If an error occurs during communication with a server, the connection will be passed to the next server, and so on until all of the functioning servers will be tried. If communication with all servers fails, the connection will be closed.</p>
<blockquote>
<p>Syntax:    server address [parameters];<br>Default:    —<br>Context:    upstream</p>
</blockquote>
<p>Defines the <code>address</code> and other <code>parameters</code> of a server. The address can be specified as a domain name or IP address with an obligatory port, or as a UNIX-domain socket path specified after the “unix:” prefix. A domain name that resolves to several IP addresses defines multiple servers at once.</p>
<p>The following parameters can be defined:  </p>
<p><code>weight=number</code><br>sets the weight of the server, by default, 1.</p>
<p><code>max_conns=number</code><br>limits the maximum number of simultaneous connections to the proxied server (1.11.5). Default value is zero, meaning there is no limit. If the server group does not reside in the shared memory, the limitation works per each worker process.  </p>
<blockquote>
<p>限制每台server的连接数，用于保护避免过载，可起到限流作用。</p>
</blockquote>
<p><code>max_fails=number</code><br>sets the number of unsuccessful attempts to communicate with the server that should happen in the duration set by the <code>fail_timeout</code> parameter to consider the server unavailable for a duration also set by the <code>fail_timeout</code> parameter. By default, the number of unsuccessful attempts is set to 1. The zero value disables the accounting of attempts. Here, an unsuccessful attempt is an error or timeout while establishing a connection with the server.  </p>
<p><code>fail_timeout=time</code>  </p>
<ul>
<li>the time during which the specified number of unsuccessful attempts to communicate with the server should happen to consider the server unavailable;</li>
<li>and the period of time the server will be considered unavailable.  </li>
</ul>
<p>By default, the parameter is set to 10 seconds.</p>
<blockquote>
<p>max_fails:表示失败几次，则标记server已宕机，剔出上游服务器。<br>fail_timeout:表示失败的重试时间。<br>假设目前设置如下：<br>max_fails=2 fail_timeout=15s<br>则代表在15秒内请求某一server失败达到2次，则认为该server已经挂了或宕机了，随后再过15秒，这15秒内不会有新的请求到达刚刚挂掉的节点上，而是会请求正在运行的server，15秒后会再有新请求尝试连接挂掉的server，如果还是失败，重复上一过程，直到恢复。</p>
</blockquote>
<p><code>backup</code>  </p>
<ul>
<li>marks the server as a backup server. Connections to the backup server will be passed when the primary servers are unavailable.</li>
<li>The parameter cannot be used along with the hash and random load balancing methods.</li>
</ul>
<blockquote>
<p>backup表示当前服务器节点是备用机，只有在其他的服务器都宕机以后， 自己才会加入到集群中，被用户访问到。</p>
</blockquote>
<p><code>down</code><br>marks the server as permanently unavailable.</p>
<blockquote>
<p>down用于标记服务节点不可用。</p>
</blockquote>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/nginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/nginx%E6%97%A5%E5%BF%97%E5%88%87%E5%89%B2/" class="post-title-link" itemprop="url">nginx日志切割</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 15:30:55" itemprop="dateCreated datePublished" datetime="2020-11-21T15:30:55+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:54" itemprop="dateModified" datetime="2021-02-23T21:21:54+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <h2 id="nginx日志切割-手动"><a href="#nginx日志切割-手动" class="headerlink" title="nginx日志切割-手动"></a>nginx日志切割-手动</h2><p>现有的日志都会存在<code>access.log</code>文件中，但是随着时间的推移，这个文件的内容越来越大，体积也越来越大，不便于运维人员查看，所以我们可以通过把这个大的日志文件切割为多份不同的小文件作为日志，切割规则可以以天为单位，如果每天有几百G或者几个T的日志的话，则可以按需以每半天或者每小时对日志切割一下。<br><strong>具体步骤如下：</strong><br>1.创建一个shell可执行文件：<code>cut_my_log.sh</code>，内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">LOG_PATH&#x3D;&quot;&#x2F;var&#x2F;log&#x2F;nginx&quot;</span><br><span class="line">RECORD_TIME&#x3D;$(date -d &quot;yesterday&quot; +%Y-%m-%d+%H:%M)</span><br><span class="line">PID&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid</span><br><span class="line">mv $&#123;LOG_PATH&#125;&#x2F;access.log $&#123;LOG_PATH&#125;&#x2F;access.$&#123;RECORD_TIME&#125;.log</span><br><span class="line">mv $&#123;LOG_PATH&#125;&#x2F;error.log $&#123;LOG_PATH&#125;&#x2F;error.$&#123;RECORD_TIME&#125;.log</span><br><span class="line"></span><br><span class="line"># 向nginx主进程发送信号，用于重新打开日志文件</span><br><span class="line">kill -USR1 &#96;cat $PID&#96;</span><br></pre></td></tr></table></figure>
<p>2.为<code>cut_my_log.sh</code>添加可执行权限：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x cut_my_log.sh</span><br></pre></td></tr></table></figure>
<p>3.测试日志切割后的结果：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;cut_my_log.sh</span><br></pre></td></tr></table></figure>
<h2 id="nginx日志切割-定时"><a href="#nginx日志切割-定时" class="headerlink" title="nginx日志切割-定时"></a>nginx日志切割-定时</h2><p><strong>使用定时任务</strong><br>  1.安装定时任务<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install crontabs</span><br></pre></td></tr></table></figure><br>  2.<code>crontabs -e</code>编辑并且添加一行新的任务：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;1 * * * * &#x2F;usr&#x2F;local&#x2F;nginx&#x2F;sbin&#x2F;cut_my_log.sh</span><br></pre></td></tr></table></figure><br>  3.重启定时任务<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service crond restart</span><br></pre></td></tr></table></figure><br>  附：常用定时任务命令：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">service crond start     &#x2F;&#x2F;启动服务</span><br><span class="line">service crond stop      &#x2F;&#x2F;关闭服务</span><br><span class="line">service crond restart   &#x2F;&#x2F;重启服务</span><br><span class="line">service crond reload    &#x2F;&#x2F;重新载入配置</span><br><span class="line">crontabs -e             &#x2F;&#x2F;编辑任务</span><br><span class="line">crontabs -l             &#x2F;&#x2F;查看任务列表</span><br></pre></td></tr></table></figure><br><strong>定时任务表达式：</strong><br>cron表达式，分为5或6个域，每个域代表一个含义，如下：</p>
<table>
<thead>
<tr>
<th align="center"></th>
<th align="center">分</th>
<th align="center">时</th>
<th align="center">日</th>
<th align="center">月</th>
<th align="center">星期</th>
<th align="center">年（可选）</th>
</tr>
</thead>
<tbody><tr>
<td align="center">取值范围</td>
<td align="center">0-59</td>
<td align="center">0-23</td>
<td align="center">1-31</td>
<td align="center">1-12</td>
<td align="center">1-7</td>
<td align="center">2020/2021/2022/…</td>
</tr>
</tbody></table>
<p><strong>常用表达式：</strong><br>  每分钟执行：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*&#x2F;1 * * * *</span><br></pre></td></tr></table></figure><br>  每日凌晨（每天晚上23:59）执行：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">59 23 * * *</span><br></pre></td></tr></table></figure><br>  每日凌晨一点执行：<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0 1 * * *</span><br></pre></td></tr></table></figure></p>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/21/nginx-conf%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/21/nginx-conf%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/" class="post-title-link" itemprop="url">nginx.conf核心配置文件</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-21 15:26:25" itemprop="dateCreated datePublished" datetime="2020-11-21T15:26:25+08:00">2020-11-21</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:11" itemprop="dateModified" datetime="2021-02-23T21:21:11+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.设置worker进程的用户，指的linux中的用户，会涉及到linux操作目录或文件的一些权限，默认为<code>nobody</code></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">#user nobody;</span><br></pre></td></tr></table></figure>
<p>2.worker进程工作数设置，一般来说CPU有几个，就设置几个，或者设置为N-1也行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">worker_processes 1;</span><br></pre></td></tr></table></figure>
<p>3.nginx日志级别<code>debug|info|notice|warn|error|crit|alert|emerg</code>,错误级别从左到右越来越大<br>4.设置nginx进程pid</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pid logs&#x2F;nginx.pid;</span><br></pre></td></tr></table></figure>
<p>5.设置工作模式</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">events &#123;</span><br><span class="line">    # 默认使用epoll</span><br><span class="line">    use epoll;</span><br><span class="line"></span><br><span class="line">    # 每个worker允许连接的客户端最大连接数</span><br><span class="line">    worker_connections  1024;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>6.http指令块，针对http网络传输的一些指令配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">http&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>7.include引入外部配置，提高可读性，避免单个配置文件过大</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">include mime.types;</span><br></pre></td></tr></table></figure>
<p>8.设定日志格式，<code>main</code>为定义的格式名称，如此access_log就可以直接使用这个变量了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#log_format  main  &#39;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &#39;</span><br><span class="line">#                  &#39;$status $body_bytes_sent &quot;$http_referer&quot; &#39;</span><br><span class="line">#                  &#39;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&#39;;</span><br><span class="line"></span><br><span class="line">#access_log  logs&#x2F;access.log  main;</span><br></pre></td></tr></table></figure>
<table>
<thead>
<tr>
<th align="left">参数名</th>
<th align="left">参数意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left">$remote_addr</td>
<td align="left">客户端IP</td>
</tr>
<tr>
<td align="left">$remote_user</td>
<td align="left">远程客户端用户名，一般为：‘-’</td>
</tr>
<tr>
<td align="left">$time_local</td>
<td align="left">时间和时区</td>
</tr>
<tr>
<td align="left">$request</td>
<td align="left">请求的url以及method</td>
</tr>
<tr>
<td align="left">$status</td>
<td align="left">响应状态码</td>
</tr>
<tr>
<td align="left">$body_bytes_sent</td>
<td align="left">响应客户端内容字节数</td>
</tr>
<tr>
<td align="left">$http_referer</td>
<td align="left">记录用户从哪个链接跳转过来的</td>
</tr>
<tr>
<td align="left">$http_user_agent</td>
<td align="left">用户所使用的代理，一般来时都是浏览器</td>
</tr>
<tr>
<td align="left">$http_x_forwarded_for</td>
<td align="left">通过代理服务器来记录客户端的IP</td>
</tr>
</tbody></table>
<p>9.<code>sendfile</code>使用高效文件传输，提升传输性能，启动后才能使用<code>tcp_nopush</code>,是指当数据表积累一定大小才发送，提高了效率</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sendfile        on;</span><br><span class="line">#tcp_nopush     on;</span><br></pre></td></tr></table></figure>
<p>10.keepalive_timeout设置客户端与服务端请求的超时时间，保证客户端多次请求的时候不会重复建立新的连接，节约资源损耗。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#keepalive_timeout  0;</span><br><span class="line">keepalive_timeout  65;</span><br></pre></td></tr></table></figure>
<p>11.gzip启用压缩，html/js/css压缩后传输会更快</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gzip on;</span><br></pre></td></tr></table></figure>
<p>12.<code>server</code>可以在<code>http</code>指令块中设置多个虚拟机  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen       80;</span><br><span class="line">        server_name  localhost;</span><br><span class="line"></span><br><span class="line">        #charset koi8-r;</span><br><span class="line"></span><br><span class="line">        #access_log  logs&#x2F;host.access.log  main;</span><br><span class="line"></span><br><span class="line">        location &#x2F; &#123;</span><br><span class="line">            root   html;</span><br><span class="line">            index  index.html index.htm;</span><br><span class="line">        &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/20/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/20/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/" class="post-title-link" itemprop="url">nginx安装与运行</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-20 22:19:47" itemprop="dateCreated datePublished" datetime="2020-11-20T22:19:47+08:00">2020-11-20</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-23 21:21:18" itemprop="dateModified" datetime="2021-02-23T21:21:18+08:00">2021-02-23</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E9%9B%86%E7%BE%A4%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">集群架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>1.去官网<a target="_blank" rel="noopener" href="http://nginx.org/">http://nginx.org/</a> 下载对应的nginx包，推荐使用稳定版本<br>2.上传nginx到linux系统<br>3.安装依赖环境<br>  （1）安装gcc环境<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install gcc-c++</span><br></pre></td></tr></table></figure><br>  （2）安装PCRE库，用于解析正则表达式<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y pcre pcre-devel</span><br></pre></td></tr></table></figure><br>  （3）zlib压缩和解压缩依赖<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y zlib zlib-devel</span><br></pre></td></tr></table></figure><br>  （4）SSL安全的加密的套接字协议层，用于HTTP安全传输，也就是https<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install y openssl openssl-devel</span><br></pre></td></tr></table></figure><br>4.解压，需要注意，解压后得到的是源码，源码需要编译后才能安装  </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -zxvf nginx-1.16.1.tar.gz</span><br></pre></td></tr></table></figure>
<p>5.编译之前，先创建nginx临时目录，如果不创建，在启动nginx的过程中会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir &#x2F;var&#x2F;temp&#x2F;nginx -p</span><br></pre></td></tr></table></figure>
<p>6.在nginx目录，输入如下命令进行配置，目的是为了创建makefile文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;configure --prefix&#x3D;&#x2F;usr&#x2F;local&#x2F;nginx \</span><br><span class="line">            --pid-path&#x3D;&#x2F;var&#x2F;run&#x2F;nginx&#x2F;nginx.pid \</span><br><span class="line">            --lock-path&#x3D;&#x2F;var&#x2F;lock&#x2F;nginx.lock \</span><br><span class="line">            --error-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;error.log \</span><br><span class="line">            --http-log-path&#x3D;&#x2F;var&#x2F;log&#x2F;nginx&#x2F;access.log \</span><br><span class="line">            --with-http_gzip_static_module \</span><br><span class="line">            --http-client-body-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;client \</span><br><span class="line">            --http-proxy-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;proxy \</span><br><span class="line">            --http-fastcgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;fastcgi \</span><br><span class="line">            --http-uwsgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;uwsgi \</span><br><span class="line">            --http-scgi-temp-path&#x3D;&#x2F;var&#x2F;temp&#x2F;nginx&#x2F;scgi</span><br></pre></td></tr></table></figure>
<p>配置命令  </p>
<table>
<thead>
<tr>
<th align="left">注解</th>
<th align="left">说明</th>
</tr>
</thead>
<tbody><tr>
<td align="left">-prefix</td>
<td align="left">指定nginx安装目录</td>
</tr>
<tr>
<td align="left">-pid-path</td>
<td align="left">指定nginx的pid</td>
</tr>
<tr>
<td align="left">-lock-path</td>
<td align="left">锁定安装文件，防止被恶意篡改或误操作</td>
</tr>
<tr>
<td align="left">-error-log-path</td>
<td align="left">错误日志</td>
</tr>
<tr>
<td align="left">-http-log-path</td>
<td align="left">http日志</td>
</tr>
<tr>
<td align="left">-with-http_gzip_static_module</td>
<td align="left">启用gzip模式，在线实时压缩输出数据流</td>
</tr>
<tr>
<td align="left">-http-client-body-temp-path</td>
<td align="left">设定客户端请求的临时目录</td>
</tr>
<tr>
<td align="left">-http-proxy-temp-path</td>
<td align="left">设定http代理临时目录</td>
</tr>
<tr>
<td align="left">-http-fastcgi-temp-path</td>
<td align="left">设定fastcgi临时目录</td>
</tr>
<tr>
<td align="left">-http-uwsgi-temp-path</td>
<td align="left">设定uwsgi临时目录</td>
</tr>
<tr>
<td align="left">-http-scgi-temp-path</td>
<td align="left">设定scgi临时目录</td>
</tr>
</tbody></table>
<p>7.make编译</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make</span><br></pre></td></tr></table></figure>
<p>8.安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">make install</span><br></pre></td></tr></table></figure>
<p>9.进入sbin目录启动nginx</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;nginx</span><br></pre></td></tr></table></figure>
<p>  停止：./nginx -s stop<br>  重新加载：./nginx -s reload<br>10.打开浏览器，访问虚拟机所处内网ip即可打开nginx默认页面，显示如下便表示安装成功</p>
<img src="/2020/11/20/nginx%E5%AE%89%E8%A3%85%E4%B8%8E%E8%BF%90%E8%A1%8C/nginx.png" class="">
<p>注意事项：  </p>
<ul>
<li>如果在云服务器安装，需要开启默认的nginx端口：80  </li>
<li>如果在虚拟机安装，需要关闭防火墙  </li>
<li>本地win或mac安装需要关闭防火墙</li>
</ul>

      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  

      
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="http://example.com/2020/11/10/SpringBoot%E5%B7%A5%E7%A8%8B%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="PD">
      <meta itemprop="description" content="Cream rises to the top.">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Hexo">
    </span>
      <header class="post-header">
        <h2 class="post-title" itemprop="name headline">
          
            <a href="/2020/11/10/SpringBoot%E5%B7%A5%E7%A8%8B%E4%B8%AD%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/" class="post-title-link" itemprop="url">SpringBoot工程中解决跨域问题</a>
        </h2>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2020-11-10 21:59:06" itemprop="dateCreated datePublished" datetime="2020-11-10T21:59:06+08:00">2020-11-10</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2021-02-21 22:17:28" itemprop="dateModified" datetime="2021-02-21T22:17:28+08:00">2021-02-21</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E5%8D%95%E4%BD%93%E6%9E%B6%E6%9E%84/" itemprop="url" rel="index"><span itemprop="name">单体架构</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
          <p>前后端在联调的时候经常会出现跨域问题，这是因为<a target="_blank" rel="noopener" href="https://developer.mozilla.org/zh-CN/docs/Web/Security/Same-origin_policy">浏览器的同源策略</a></p>
<p><strong>什么是跨域？</strong></p>
<blockquote>
<p>浏览器从一个域名的网页去请求另一个域名的资源时，协议、主机、端口任一不同，都是跨域。</p>
</blockquote>
<p>下表给出了与URL<code>http://store.company.com/dir/page.html</code>的源进行比对的示例：</p>
<table>
<thead>
<tr>
<th align="left">URL</th>
<th align="left">结果</th>
<th align="left">原因</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><code>http://store.company.com/dir2/other.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com/dir/inner/another.html</code></td>
<td align="left">同源</td>
<td align="left">只有路径不同</td>
</tr>
<tr>
<td align="left"><code>https://store.company.com/secure.html</code></td>
<td align="left">失败</td>
<td align="left">协议不同</td>
</tr>
<tr>
<td align="left"><code>http://store.company.com:81/dir/etc.html</code></td>
<td align="left">失败</td>
<td align="left">端口不同（<code>http://</code>默认端口是80）</td>
</tr>
<tr>
<td align="left"><code>http://news.company.com/dir/other.html</code></td>
<td align="left">失败</td>
<td align="left">主机不同</td>
</tr>
</tbody></table>
<p>SpringBoot工程配置Configuration解决跨域问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">package com.phd.config;</span><br><span class="line"></span><br><span class="line">import org.springframework.context.annotation.Bean;</span><br><span class="line">import org.springframework.context.annotation.Configuration;</span><br><span class="line">import org.springframework.web.cors.CorsConfiguration;</span><br><span class="line">import org.springframework.web.cors.UrlBasedCorsConfigurationSource;</span><br><span class="line">import org.springframework.web.filter.CorsFilter;</span><br><span class="line"></span><br><span class="line">@Configuration</span><br><span class="line">public class CorsConfig &#123;</span><br><span class="line"></span><br><span class="line">    public CorsConfig() &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    @Bean</span><br><span class="line">    public CorsFilter corsFilter() &#123;</span><br><span class="line">        &#x2F;&#x2F; 1. 添加cors配置信息</span><br><span class="line">        CorsConfiguration config &#x3D; new CorsConfiguration();</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F;允许跨域请求的域，*代表所有</span><br><span class="line">        config.addAllowedOrigin(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置是否发送cookie信息</span><br><span class="line">        config.setAllowCredentials(true);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置允许请求的方式</span><br><span class="line">        config.addAllowedMethod(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 设置允许的header</span><br><span class="line">        config.addAllowedHeader(&quot;*&quot;);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 2. 为url添加映射路径</span><br><span class="line">        UrlBasedCorsConfigurationSource corsSource &#x3D; new UrlBasedCorsConfigurationSource();</span><br><span class="line">        corsSource.registerCorsConfiguration(&quot;&#x2F;**&quot;, config);</span><br><span class="line"></span><br><span class="line">        &#x2F;&#x2F; 3. 返回重新定义好的corsSource</span><br><span class="line">        return new CorsFilter(corsSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
      
    </div>

    
    
    
      <footer class="post-footer">
        <div class="post-eof"></div>
      </footer>
  </article>
  
  
  


  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left" aria-label="上一页"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right" aria-label="下一页"></i></a>
  </nav>



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">

      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">PD</p>
  <div class="site-description" itemprop="description">Cream rises to the top.</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">26</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">14</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2021</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">PD</span>
</div>
  <div class="powered-by">由 <a href="https://hexo.io/" class="theme-link" rel="noopener" target="_blank">Hexo</a> & <a href="https://mist.theme-next.org/" class="theme-link" rel="noopener" target="_blank">NexT.Mist</a> 强力驱动
  </div>

        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  















  

  

</body>
</html>
